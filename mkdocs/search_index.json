{
    "docs": [
        {
            "location": "/",
            "text": "Installation\n\n\nLuwra is a header-only library, which means that nothing has to be compiled in order to use it.\nSimply clone the \nrepository\n or\n\ndownload\n it and extract it to a directory\nof your preference.\n\n\nFor your application to be able to reach the \nlib/luwra.hpp\n header file, you must add\n\n/path/to/luwra/lib\n to the list of include paths. With Clang and GCC that is done using the\n\n-I/path/to/luwra/lib\n command-line parameter.\n\n\nNow you can simply \n#include <luwra.hpp>\n in your C++ files and start using Luwra.\n\n\nIntegration\n\n\nThis library does not provide a standalone version of Lua nor does it isolate its features. This\nmeans that all functions and classes can operate on \nlua_State\n (or the alias\n\nState\n). Doing this allows you to integrate Luwra however you like.\n\n\nNevertheless, you must have a version of Lua installed. Luwra will include the necessary header\nfiles, but it can't link against the Lua library itself.\n\n\nReference Manual\n\n\nA reference manual exists \nhere\n.",
            "title": "Home"
        },
        {
            "location": "/#installation",
            "text": "Luwra is a header-only library, which means that nothing has to be compiled in order to use it.\nSimply clone the  repository  or download  it and extract it to a directory\nof your preference.  For your application to be able to reach the  lib/luwra.hpp  header file, you must add /path/to/luwra/lib  to the list of include paths. With Clang and GCC that is done using the -I/path/to/luwra/lib  command-line parameter.  Now you can simply  #include <luwra.hpp>  in your C++ files and start using Luwra.",
            "title": "Installation"
        },
        {
            "location": "/#integration",
            "text": "This library does not provide a standalone version of Lua nor does it isolate its features. This\nmeans that all functions and classes can operate on  lua_State  (or the alias State ). Doing this allows you to integrate Luwra however you like.  Nevertheless, you must have a version of Lua installed. Luwra will include the necessary header\nfiles, but it can't link against the Lua library itself.",
            "title": "Integration"
        },
        {
            "location": "/#reference-manual",
            "text": "A reference manual exists  here .",
            "title": "Reference Manual"
        },
        {
            "location": "/values/",
            "text": "Values\n\n\nA fundamental part of Luwra is the \nValue\n template which acts as a type class. It is\nused to define \nread\n and \npush\n behavior for certain types.\n\n\nA type \nT\n is considered \nreadable\n if a function \nT Value<T>::read(State*, int)\n exists. The\nreturn type of that function need not be \nT\n, instead it can be anything that is convertible to \nT\n.\n\n\nA type \nT\n is considered \npushable\n if a funtion \nvoid Value<T>::push(State*, T)\n exists. In order\nto avoid unnecessary copying, the second parameter type may also be \nconst T&\n.\n\n\nDefault Implementations\n\n\nSeveral useful specializations are provided out of the box.\n\n\n\n\n\n\n\n\nC++ type\n\n\nPushable\n\n\nReadable\n\n\nLua type\n\n\n\n\n\n\n\n\n\n\nbool\n\n\nyes\n\n\nyes\n\n\nboolean\n\n\n\n\n\n\nsigned char\n\n\nyes\n\n\nyes\n\n\nnumber (integer since 5.3)\n\n\n\n\n\n\nsigned short\n\n\nyes\n\n\nyes\n\n\nnumber (integer since 5.3)\n\n\n\n\n\n\nsigned int\n\n\nyes\n\n\nyes\n\n\nnumber (integer since 5.3)\n\n\n\n\n\n\nsigned long int\n\n\nyes\n\n\nyes\n\n\nnumber (integer since 5.3)\n\n\n\n\n\n\nsigned long long int\n\n\nyes\n\n\nyes\n\n\nnumber (integer since 5.3)\n\n\n\n\n\n\nunsigned char\n\n\nyes\n\n\nyes\n\n\nnumber (integer since 5.3)\n\n\n\n\n\n\nunsigned short\n\n\nyes\n\n\nyes\n\n\nnumber (integer since 5.3)\n\n\n\n\n\n\nunsigned int\n\n\nyes\n\n\nyes\n\n\nnumber (integer since 5.3)\n\n\n\n\n\n\nunsigned long int\n\n\nyes\n\n\nyes\n\n\nnumber (integer since 5.3)\n\n\n\n\n\n\nunsigned long long int\n\n\nyes\n\n\nyes\n\n\nnumber (integer since 5.3)\n\n\n\n\n\n\nfloat\n\n\nyes\n\n\nyes\n\n\nnumber\n\n\n\n\n\n\ndouble\n\n\nyes\n\n\nyes\n\n\nnumber\n\n\n\n\n\n\nlong double\n\n\nyes\n\n\nyes\n\n\nnumber\n\n\n\n\n\n\nconst char*\n\n\nyes\n\n\nyes\n\n\nstring\n\n\n\n\n\n\nstd::string\n\n\nyes\n\n\nyes\n\n\nstring\n\n\n\n\n\n\nstd::nullptr_t\n\n\nyes\n\n\nyes\n\n\nnil\n\n\n\n\n\n\nstd::vector<T>\n\n\nyes\n\n\nno\n\n\ntable\n\n\n\n\n\n\nstd::list<T>\n\n\nyes\n\n\nno\n\n\ntable\n\n\n\n\n\n\nstd::map<K, V>\n\n\nyes\n\n\nno\n\n\ntable\n\n\n\n\n\n\nlua_CFunction\n\n\nyes\n\n\nno\n\n\nfunction\n\n\n\n\n\n\nFunction\n\n\nyes\n\n\nyes\n\n\nfunction, table or userdata\n\n\n\n\n\n\nTable\n\n\nyes\n\n\nyes\n\n\ntable\n\n\n\n\n\n\n\n\nNote:\n Some numeric types have a different size than their matching Lua type - they will be\ntruncated during \nread\n or \npush\n operations.\n\n\nArbitrary and User Types\n\n\nValue\n provides a catch-all generalization for types that do not have a specialization\nof \nValue\n. Although these types are not known to Luwra, they are pushable and\nreadable.\n\n\nInstances of these so-called \nuser types\n are constructed on the Lua stack as a\n\nfull userdata\n. Additionally, a metatable that is specific to the given user type is\nattached to the userdata. This metatable allows us to check whether a userdata is an instance of a\nspecific user type.\n\n\npush\n operations always copy or move instances of the user type onto the stack, whereas \nread\n\noperations always reference the user type value on the stack.\n\n\nBy default, the metatables that are attached to the user type values are empty. Because of this,\nthey provide no functionality to Lua and are never destructed (underlying storage is just freed).\nYou can change this behavior, read more in the \nUser Types\n section.\n\n\nExtending Value\n\n\nYou can customize the \nread\n and \npush\n behavior for your own type \nT\n. Simply modify the following\nsnippet and insert it outside of any namespace.\n\n\nnamespace luwra {\n    template <>\n    struct Value<T> {\n        static inline\n        T read(State* state, int index) {\n            return /* Return the instance of T that you have read at the given index */;\n        }\n\n        static inline\n        void push(State* state, const T& value) {\n            // Push the given value on top of the stack\n        }\n    };\n}\n\n\n\n\nReturn Values\n\n\nThe template \nReturnValues\n extends the \npush\n functionality on top of\n\nValue\n by allowing more complex types to be pushed onto the stack.\n\n\nReturnValues\n makes it possible to use \nstd::tuple<...>\n or \nstd::pair<...>\n as\nreturn type of user-provided functions in order to mimic the ability of Lua functions to return\nmultiple values at once.\n\n\nRead and Type Errors\n\n\nLuwra does not handle errors. Instead it delegates the error handling to Lua.\nSee \nError Handling in C\n for more information.\n\n\nIt is highly recommended that you use a version of Lua that has been compiled as C++. Doing\notherwise might lead to improper stack unwinding in case of an error which causes resources to be\nleaked, since the calling of destructors is not guaranteed.",
            "title": "Values"
        },
        {
            "location": "/values/#values",
            "text": "A fundamental part of Luwra is the  Value  template which acts as a type class. It is\nused to define  read  and  push  behavior for certain types.  A type  T  is considered  readable  if a function  T Value<T>::read(State*, int)  exists. The\nreturn type of that function need not be  T , instead it can be anything that is convertible to  T .  A type  T  is considered  pushable  if a funtion  void Value<T>::push(State*, T)  exists. In order\nto avoid unnecessary copying, the second parameter type may also be  const T& .",
            "title": "Values"
        },
        {
            "location": "/values/#default-implementations",
            "text": "Several useful specializations are provided out of the box.     C++ type  Pushable  Readable  Lua type      bool  yes  yes  boolean    signed char  yes  yes  number (integer since 5.3)    signed short  yes  yes  number (integer since 5.3)    signed int  yes  yes  number (integer since 5.3)    signed long int  yes  yes  number (integer since 5.3)    signed long long int  yes  yes  number (integer since 5.3)    unsigned char  yes  yes  number (integer since 5.3)    unsigned short  yes  yes  number (integer since 5.3)    unsigned int  yes  yes  number (integer since 5.3)    unsigned long int  yes  yes  number (integer since 5.3)    unsigned long long int  yes  yes  number (integer since 5.3)    float  yes  yes  number    double  yes  yes  number    long double  yes  yes  number    const char*  yes  yes  string    std::string  yes  yes  string    std::nullptr_t  yes  yes  nil    std::vector<T>  yes  no  table    std::list<T>  yes  no  table    std::map<K, V>  yes  no  table    lua_CFunction  yes  no  function    Function  yes  yes  function, table or userdata    Table  yes  yes  table     Note:  Some numeric types have a different size than their matching Lua type - they will be\ntruncated during  read  or  push  operations.",
            "title": "Default Implementations"
        },
        {
            "location": "/values/#arbitrary-and-user-types",
            "text": "Value  provides a catch-all generalization for types that do not have a specialization\nof  Value . Although these types are not known to Luwra, they are pushable and\nreadable.  Instances of these so-called  user types  are constructed on the Lua stack as a full userdata . Additionally, a metatable that is specific to the given user type is\nattached to the userdata. This metatable allows us to check whether a userdata is an instance of a\nspecific user type.  push  operations always copy or move instances of the user type onto the stack, whereas  read \noperations always reference the user type value on the stack.  By default, the metatables that are attached to the user type values are empty. Because of this,\nthey provide no functionality to Lua and are never destructed (underlying storage is just freed).\nYou can change this behavior, read more in the  User Types  section.",
            "title": "Arbitrary and User Types"
        },
        {
            "location": "/values/#extending-value",
            "text": "You can customize the  read  and  push  behavior for your own type  T . Simply modify the following\nsnippet and insert it outside of any namespace.  namespace luwra {\n    template <>\n    struct Value<T> {\n        static inline\n        T read(State* state, int index) {\n            return /* Return the instance of T that you have read at the given index */;\n        }\n\n        static inline\n        void push(State* state, const T& value) {\n            // Push the given value on top of the stack\n        }\n    };\n}",
            "title": "Extending Value"
        },
        {
            "location": "/values/#return-values",
            "text": "The template  ReturnValues  extends the  push  functionality on top of Value  by allowing more complex types to be pushed onto the stack.  ReturnValues  makes it possible to use  std::tuple<...>  or  std::pair<...>  as\nreturn type of user-provided functions in order to mimic the ability of Lua functions to return\nmultiple values at once.",
            "title": "Return Values"
        },
        {
            "location": "/values/#read-and-type-errors",
            "text": "Luwra does not handle errors. Instead it delegates the error handling to Lua.\nSee  Error Handling in C  for more information.  It is highly recommended that you use a version of Lua that has been compiled as C++. Doing\notherwise might lead to improper stack unwinding in case of an error which causes resources to be\nleaked, since the calling of destructors is not guaranteed.",
            "title": "Read and Type Errors"
        },
        {
            "location": "/stack/",
            "text": "Stack Interaction\n\n\nLuwra provides several easy ways to interact with the Lua virtual stack.\n\n\nPushing Values\n\n\nTo get values onto the stack, use \npush\n.\n\n\nluwra::push(state, 1337);\n\n\n\n\nluwra::push(state, 13.37);\n\n\n\n\nluwra::push(state, \"Hello World\");\n\n\n\n\nluwra::push(state, MyUserType(\"Hello\", 5));\n\n\n\n\nYou can also push them all at once.\n\n\nluwra::push(state, 1337, 13.37, \"Hello World\", MyUserType(\"Hello\", 5));\n\n\n\n\nReading Values\n\n\nReading values works with \nread\n. Assuming the stack has been prepared as it has been in\nthe previous section, you can extract the values like so.\n\n\nint i = luwra::read<int>(state, 1);\n\n\n\n\ndouble d = luwra::read<double>(state, 2);\n\n\n\n\nstd::string s = luwra::read<std::string>(state, 3);\n\n\n\n\nMyUserType& u = luwra::read<MyUserType>(state, 4);\n\n\n\n\nYou can also let C++ infer the types for you.\n\n\nint i = luwra::read(state, 1);\n\n\n\n\ndouble d = luwra::read(state, 2);\n\n\n\n\nstd::string s = luwra::read(state, 3);\n\n\n\n\nMyUserType& u = luwra::read(state, 4);\n\n\n\n\nNote:\n Type inference does not work with every compiler. Particularly GCC before version 4.9.2 is\naffected by this problem.\n\n\nInvoke Callables with Stack Values\n\n\napply\n is a function that retrieves values from the stack in order to invoke a given\n\nCallable\n. The types of values on the stack are deduced from the parameter types to the \nCallable\n.\n\n\nstd::string substring(const std::string& str, size_t len) {\n    return str.substr(0, len);\n}\n\n\n\n\nluwra::push(state, \"Hello World\");\nluwra::push(state, 5);\n\n// Retrieve values and invoke 'substring'.\nstd::string result = luwra::apply(state, 1, substring);\n\n// The string is essentially equal to the following.\nstd::result result = substring(luwra::read(state, 1), luwra::read(state, 2));\n\n// You can also provide your own arguments before the stack values.\nstd::string result = luwra::apply(state, 2, substring, \"My Own String\");\n\n// Alternatively\nstd::string result = substring(\"My Own String\", luwra::read(state, 2));\n\n\n\n\nIf you wish to return the result of your function to the stack, simply use \nmap\n.\n\n\nluwra::map(state, 1, substring);\nstd::string result = luwra::read(state, -1);\n\n\n\n\nYou can also provide function objects or lambdas to \napply\n and \nmap\n.\n\n\nstd::string result = luwra::apply(state, 1, [](const std::string& str, size_t len) {\n    return str.substr(0, len);\n});",
            "title": "Stack Interaction"
        },
        {
            "location": "/stack/#stack-interaction",
            "text": "Luwra provides several easy ways to interact with the Lua virtual stack.",
            "title": "Stack Interaction"
        },
        {
            "location": "/stack/#pushing-values",
            "text": "To get values onto the stack, use  push .  luwra::push(state, 1337);  luwra::push(state, 13.37);  luwra::push(state, \"Hello World\");  luwra::push(state, MyUserType(\"Hello\", 5));  You can also push them all at once.  luwra::push(state, 1337, 13.37, \"Hello World\", MyUserType(\"Hello\", 5));",
            "title": "Pushing Values"
        },
        {
            "location": "/stack/#reading-values",
            "text": "Reading values works with  read . Assuming the stack has been prepared as it has been in\nthe previous section, you can extract the values like so.  int i = luwra::read<int>(state, 1);  double d = luwra::read<double>(state, 2);  std::string s = luwra::read<std::string>(state, 3);  MyUserType& u = luwra::read<MyUserType>(state, 4);  You can also let C++ infer the types for you.  int i = luwra::read(state, 1);  double d = luwra::read(state, 2);  std::string s = luwra::read(state, 3);  MyUserType& u = luwra::read(state, 4);  Note:  Type inference does not work with every compiler. Particularly GCC before version 4.9.2 is\naffected by this problem.",
            "title": "Reading Values"
        },
        {
            "location": "/stack/#invoke-callables-with-stack-values",
            "text": "apply  is a function that retrieves values from the stack in order to invoke a given Callable . The types of values on the stack are deduced from the parameter types to the  Callable .  std::string substring(const std::string& str, size_t len) {\n    return str.substr(0, len);\n}  luwra::push(state, \"Hello World\");\nluwra::push(state, 5);\n\n// Retrieve values and invoke 'substring'.\nstd::string result = luwra::apply(state, 1, substring);\n\n// The string is essentially equal to the following.\nstd::result result = substring(luwra::read(state, 1), luwra::read(state, 2));\n\n// You can also provide your own arguments before the stack values.\nstd::string result = luwra::apply(state, 2, substring, \"My Own String\");\n\n// Alternatively\nstd::string result = substring(\"My Own String\", luwra::read(state, 2));  If you wish to return the result of your function to the stack, simply use  map .  luwra::map(state, 1, substring);\nstd::string result = luwra::read(state, -1);  You can also provide function objects or lambdas to  apply  and  map .  std::string result = luwra::apply(state, 1, [](const std::string& str, size_t len) {\n    return str.substr(0, len);\n});",
            "title": "Invoke Callables with Stack Values"
        },
        {
            "location": "/state/",
            "text": "State Wrapper\n\n\nDocument me, please.",
            "title": "State Wrapper"
        },
        {
            "location": "/state/#state-wrapper",
            "text": "Document me, please.",
            "title": "State Wrapper"
        },
        {
            "location": "/utilities/",
            "text": "Utilities\n\n\nDocument me, please.",
            "title": "Utilities"
        },
        {
            "location": "/utilities/#utilities",
            "text": "Document me, please.",
            "title": "Utilities"
        },
        {
            "location": "/wrapping/",
            "text": "Wrapping\n\n\nLuwra provides a simple way to generate Lua \nC functions\n from functions and class\nmembers like methods and accessors using the \nLUWRA_WRAP\n macro. These kind of C\nfunctions are useful, because they work just like regular Lua functions within the Lua virtual\nmachine. Registering these functions is the most straightforward way of providing the functionality\nof your application to Lua.\n\n\nFunctions\n\n\nWhen wrapping functions, one must consider that all parameter types must be read from the\nstack and the return type must be pushed onto the stack.\n\n\nExample\n\n\nLets assume you want to make the following function available in Lua.\n\n\nint my_function(const char* a, int b);\n\n\n\n\nFirst, you must generate a Lua \nC function\n. One utilizes the\n\nLUWRA_WRAP\n macro for this.\n\n\nlua_CFunction cfun = LUWRA_WRAP(my_function);\n\n\n\n\nNote:\n Do not provide the address of your function (e.g. \n&my_function\n) to any wrapping macro.\nThe macro will take care of this itself. You must provide only the name of the function.\n\n\nOnce you have the C function, you can register it in the global namespace.\n\n\nluwra::setGlobal(lua, \"my_function\", cfun);\n\n\n\n\nInvoking the function in Lua is fairly straightforward.\n\n\nprint(my_function(\"Hello World\", 1337))\n\n\n\n\nPerformance\n\n\nC functions\n are dynamically created at compile-time. All of the functions involved\nin wrapping are marked as \ninline\n, which means modern compilers produce wrapper functions with zero\noverhead, when optimization is turned on.\n\n\nFor the example above, the resulting code would look similiar to the following.\n\n\nint cfun(lua_State* state) {\n    lua_pushinteger(\n        state,\n        my_function(\n            luaL_checkstring(state, 1),\n            luaL_checkinteger(state, 2)\n        )\n    );\n    return 1;\n}\n\n\n\n\nClass Members\n\n\nAlthough a little trickier, it is also possible to turn C++ field accessors and methods into Lua\n\nC functions\n. The resulting Lua functions expect the first (or \nself\n) parameter to\nbe an instance of the type which the wrapped field or method belongs to.\n\n\nNote:\n Before you wrap fields and methods manually, you might want to take a look at the\n\nUser Types\n section.\n\n\nExample\n\n\nThis example will operate on the following structure.\n\n\nstruct Point {\n    double x, y;\n\n    // ...\n\n    void scale(double f) {\n        x *= f;\n        y *= f;\n    }\n};\n\n\n\n\nWrapping field accessors and methods works similar to wrapping functions.\n\n\nlua_CFunction cfun_x     = LUWRA_WRAP_MEMBER(Point, x),\n              cfun_y     = LUWRA_WRAP_MEMBER(Point, y),\n              cfun_scale = LUWRA_WRAP_MEMBER(Point, scale);\n\n// Register in global namespace\nluwra::setGlobal(lua, \"x\", cfun_x);\nluwra::setGlobal(lua, \"y\", cfun_y);\nluwra::setGlobal(lua, \"scale\", cfun_scale);\n\n\n\n\nNote:\n In this case, it is also possible to use \nLUWRA_WRAP\n to generate the C\nfunctions. The usage of \nLUWRA_WRAP_MEMBER\n is only required when working with\ninherited members, since it is impossible for the \nLUWRA_WRAP\n macro to be aware of\ninherited members.\n\n\nFor example, if you are trying to wrap a member \nB::foo\n where \nfoo\n is an inherited member of class\n\nA\n which \nB\n derives from, then \nLUWRA_WRAP(B::foo)\n would generate a function which is only\napplicable on instances of \nA\n. But \nLUWRA_WRAP_MEMBER(B, foo)\n generates a function that can only\nbe applied to instances of \nB\n.\n\n\nUsage in Lua is analogous to function usage.\n\n\n-- Instantiate 'Point' here, have a look at the User Types section to find out how to do this\nlocal my_point = ...\n\n-- Access 'x' and 'y' field\nprint(x(my_point), y(my_point))\n\n-- Set 'x' and 'y' field\nx(my_point, 13.37)\ny(my_point, 73.31)\n\n-- Invoke 'scale' method\nscale(my_point, 2)",
            "title": "Wrapping"
        },
        {
            "location": "/wrapping/#wrapping",
            "text": "Luwra provides a simple way to generate Lua  C functions  from functions and class\nmembers like methods and accessors using the  LUWRA_WRAP  macro. These kind of C\nfunctions are useful, because they work just like regular Lua functions within the Lua virtual\nmachine. Registering these functions is the most straightforward way of providing the functionality\nof your application to Lua.",
            "title": "Wrapping"
        },
        {
            "location": "/wrapping/#functions",
            "text": "When wrapping functions, one must consider that all parameter types must be read from the\nstack and the return type must be pushed onto the stack.",
            "title": "Functions"
        },
        {
            "location": "/wrapping/#example",
            "text": "Lets assume you want to make the following function available in Lua.  int my_function(const char* a, int b);  First, you must generate a Lua  C function . One utilizes the LUWRA_WRAP  macro for this.  lua_CFunction cfun = LUWRA_WRAP(my_function);  Note:  Do not provide the address of your function (e.g.  &my_function ) to any wrapping macro.\nThe macro will take care of this itself. You must provide only the name of the function.  Once you have the C function, you can register it in the global namespace.  luwra::setGlobal(lua, \"my_function\", cfun);  Invoking the function in Lua is fairly straightforward.  print(my_function(\"Hello World\", 1337))",
            "title": "Example"
        },
        {
            "location": "/wrapping/#performance",
            "text": "C functions  are dynamically created at compile-time. All of the functions involved\nin wrapping are marked as  inline , which means modern compilers produce wrapper functions with zero\noverhead, when optimization is turned on.  For the example above, the resulting code would look similiar to the following.  int cfun(lua_State* state) {\n    lua_pushinteger(\n        state,\n        my_function(\n            luaL_checkstring(state, 1),\n            luaL_checkinteger(state, 2)\n        )\n    );\n    return 1;\n}",
            "title": "Performance"
        },
        {
            "location": "/wrapping/#class-members",
            "text": "Although a little trickier, it is also possible to turn C++ field accessors and methods into Lua C functions . The resulting Lua functions expect the first (or  self ) parameter to\nbe an instance of the type which the wrapped field or method belongs to.  Note:  Before you wrap fields and methods manually, you might want to take a look at the User Types  section.",
            "title": "Class Members"
        },
        {
            "location": "/wrapping/#example_1",
            "text": "This example will operate on the following structure.  struct Point {\n    double x, y;\n\n    // ...\n\n    void scale(double f) {\n        x *= f;\n        y *= f;\n    }\n};  Wrapping field accessors and methods works similar to wrapping functions.  lua_CFunction cfun_x     = LUWRA_WRAP_MEMBER(Point, x),\n              cfun_y     = LUWRA_WRAP_MEMBER(Point, y),\n              cfun_scale = LUWRA_WRAP_MEMBER(Point, scale);\n\n// Register in global namespace\nluwra::setGlobal(lua, \"x\", cfun_x);\nluwra::setGlobal(lua, \"y\", cfun_y);\nluwra::setGlobal(lua, \"scale\", cfun_scale);  Note:  In this case, it is also possible to use  LUWRA_WRAP  to generate the C\nfunctions. The usage of  LUWRA_WRAP_MEMBER  is only required when working with\ninherited members, since it is impossible for the  LUWRA_WRAP  macro to be aware of\ninherited members.  For example, if you are trying to wrap a member  B::foo  where  foo  is an inherited member of class A  which  B  derives from, then  LUWRA_WRAP(B::foo)  would generate a function which is only\napplicable on instances of  A . But  LUWRA_WRAP_MEMBER(B, foo)  generates a function that can only\nbe applied to instances of  B .  Usage in Lua is analogous to function usage.  -- Instantiate 'Point' here, have a look at the User Types section to find out how to do this\nlocal my_point = ...\n\n-- Access 'x' and 'y' field\nprint(x(my_point), y(my_point))\n\n-- Set 'x' and 'y' field\nx(my_point, 13.37)\ny(my_point, 73.31)\n\n-- Invoke 'scale' method\nscale(my_point, 2)",
            "title": "Example"
        },
        {
            "location": "/usertypes/",
            "text": "User Types\n\n\nA user type is a collection of class members bundled into a metatable. In order to use all class\nmembers, one must register the type's metatable in Lua's registry.\n\n\nThe following examples work on this class:\n\n\nstruct Point {\n    double x, y;\n\n    Point(double x, double y):\n        x(x), y(y)\n    {\n        std::cout << \"Construct Point(\" << x << \", \" << y << \")\" << std::endl;\n    }\n\n    ~Point() {\n        std::cout << \"Destruct Point(\" << x << \", \" << y << \")\" << std::endl;\n    }\n\n    void scale(double f) {\n        x *= f;\n        y *= f;\n    }\n\n    std::string __tostring() {\n        return \"<Point(\" + std::to_string(x) + \", \" + std::to_string(y) + \")>\";\n    }\n};\n\n\n\n\nRegister User Type with Constructor\n\n\nregisterUserType<UserType(CtorArgs...)>\n allows you to register a\nmetatable for \nUserType\n and a constructor for it with the parameter types \nCtorArgs...\n in the\nglobal namespace.\n\n\nBy default, the function generates a garbage-collector hook and a string representation function.\nIf you add a \n__gc\n or \n__tostring\n meta method to your type, these auto-generated functions will be\noverridden.\n\n\nluwra::registerUserType<Point(double, double)>(\n    lua,\n\n    // Constructor name\n    \"Point\",\n\n    // Methods need to be declared here\n    {\n        LUWRA_MEMBER(Point, scale),\n        LUWRA_MEMBER(Point, x),\n        LUWRA_MEMBER(Point, y)\n    },\n\n    // Meta methods may be registered aswell\n    {\n        LUWRA_MEMBER(Point, __tostring)\n    }\n);\n\n\n\n\nThe \nLUWRA_MEMBER\n macro generates an expression which initializes a key-value\nassociation.\n\n\nLUWRA_MEMBER(Point, scale) == {\"scale\", LUWRA_WRAP_MEMBER(Point, scale)}\n\n\n\n\nPushable\n is constructible using every pushable type, which makes it convenient to\nadd other types of fields:\n\n\nluwra::registerUserType<Point(double, double)>(\n    lua,\n\n    // Constructor name\n    \"Point\",\n\n    // Methods need to be declared here\n    {\n        {\"scale\", LUWRA_WRAP_MEMBER(Point, scale)},\n        {\"x\",     LUWRA_WRAP_MEMBER(Point, x)},\n        {\"y\",     LUWRA_WRAP_MEMBER(Point, y)},\n        {\"magic\", luwra::MemberMap {\n            {\"number\", 1337},\n            {\"string\", \"Hello World\"}\n        }}\n    },\n\n    // Meta methods may be registered aswell\n    {\n        {\"__tostring\", LUWRA_WRAP_MEMBER(Point, __tostring)}\n    }\n);\n\n\n\n\nRegister User Type without Constructor\n\n\nTo register only the metatable associated with a user type, simply omit the constructor parameters\nand name from the call to \nregisterUserType\n.\n\n\nluwra::registerUserType<Point>(\n    lua,\n\n    // Methods need to be declared here\n    {\n        {\"scale\", LUWRA_WRAP_MEMBER(Point, scale)},\n        {\"x\",     LUWRA_WRAP_MEMBER(Point, x)},\n        {\"y\",     LUWRA_WRAP_MEMBER(Point, y)},\n        {\"magic\", luwra::MemberMap {\n            {\"number\", 1337},\n            {\"string\", \"Hello World\"}\n        }}\n    },\n\n    // Meta methods may be registered aswell\n    {\n        {\"__tostring\", LUWRA_WRAP_MEMBER(Point, __tostring)}\n    }\n);\n\n\n\n\nIt is still possible to provide a constructor using the\n\nLUWRA_WRAP_CONSTRUCTOR\n macro:\n\n\nlua_CFunction ctor = LUWRA_WRAP_CONSTRUCTOR(Point, double, double);\nluwra::setGlobal(lua, \"Point\", ctor);\n\n\n\n\nUsage in Lua\n\n\nAfter you have registered your user type using one of the given methods, you can start using it in\nLua:\n\n\n-- Instantiate 'Point'\nlocal point = Point(13, 37)\n\n-- Invoke 'scale' method\npoint:scale(1.5)\n\n-- Convert to string via '__tostring' meta method\nprint(point)\n\n-- Read properties 'x' and 'y'\nprint(point:x(), point:y())\n\n-- Set property 'x'\npoint:x(point.magic.number)\n\n\n\n\nManually constructing a User Type\n\n\nconstruct\n provides this functionality. Given the user type and constructor\nparameters, it will construct the user type on top of the stack:\n\n\nPoint& my_point = luwra::construct<Point>(lua, 13.37, 73.31);\n\n// Changes on C++ side will be visible in Lua\nmy_point.scale(2);\n\n\n\n\nRegistry Names\n\n\nWhen registering the metatable for a user type, an automatically generated name will be used to\nstore it in the registry. When Luwra is used in a single executable or shared library, name\ncollisions should not happen. If your application consists of multiple seperate compiled units, it\nis highly recommended to prevent name collisions by defining the \nLUWRA_REGISTRY_PREFIX\n macro\nbefore including the Luwra headers. This macro changes the prefix for auto-generated registry names.\n\n\n#define LUWRA_REGISTRY_PREFIX \"MyProject#\"\n#include <luwra.hpp>\n\n\n\n\nAnother way to prevent collisons is to give each user type its individual registry name. This can be\ndone using the \nLUWRA_DEF_REGISTRY_NAME\n macro.\n\n\nstruct MyUserType {\n    // ...\n};\n\nLUWRA_DEF_REGISTRY_NAME(MyUserType, \"MyUserType\")\n\n\n\n\nThis method will not prefix the registry name with the value of \nLUWRA_REGISTRY_PREFIX\n.\nThe \nLUWRA_DEF_REGISTRY_NAME\n macro has to be used at the root namespace,\nusing it inside a namespace scope will have no effect.",
            "title": "User Types"
        },
        {
            "location": "/usertypes/#user-types",
            "text": "A user type is a collection of class members bundled into a metatable. In order to use all class\nmembers, one must register the type's metatable in Lua's registry.  The following examples work on this class:  struct Point {\n    double x, y;\n\n    Point(double x, double y):\n        x(x), y(y)\n    {\n        std::cout << \"Construct Point(\" << x << \", \" << y << \")\" << std::endl;\n    }\n\n    ~Point() {\n        std::cout << \"Destruct Point(\" << x << \", \" << y << \")\" << std::endl;\n    }\n\n    void scale(double f) {\n        x *= f;\n        y *= f;\n    }\n\n    std::string __tostring() {\n        return \"<Point(\" + std::to_string(x) + \", \" + std::to_string(y) + \")>\";\n    }\n};",
            "title": "User Types"
        },
        {
            "location": "/usertypes/#register-user-type-with-constructor",
            "text": "registerUserType<UserType(CtorArgs...)>  allows you to register a\nmetatable for  UserType  and a constructor for it with the parameter types  CtorArgs...  in the\nglobal namespace.  By default, the function generates a garbage-collector hook and a string representation function.\nIf you add a  __gc  or  __tostring  meta method to your type, these auto-generated functions will be\noverridden.  luwra::registerUserType<Point(double, double)>(\n    lua,\n\n    // Constructor name\n    \"Point\",\n\n    // Methods need to be declared here\n    {\n        LUWRA_MEMBER(Point, scale),\n        LUWRA_MEMBER(Point, x),\n        LUWRA_MEMBER(Point, y)\n    },\n\n    // Meta methods may be registered aswell\n    {\n        LUWRA_MEMBER(Point, __tostring)\n    }\n);  The  LUWRA_MEMBER  macro generates an expression which initializes a key-value\nassociation.  LUWRA_MEMBER(Point, scale) == {\"scale\", LUWRA_WRAP_MEMBER(Point, scale)}  Pushable  is constructible using every pushable type, which makes it convenient to\nadd other types of fields:  luwra::registerUserType<Point(double, double)>(\n    lua,\n\n    // Constructor name\n    \"Point\",\n\n    // Methods need to be declared here\n    {\n        {\"scale\", LUWRA_WRAP_MEMBER(Point, scale)},\n        {\"x\",     LUWRA_WRAP_MEMBER(Point, x)},\n        {\"y\",     LUWRA_WRAP_MEMBER(Point, y)},\n        {\"magic\", luwra::MemberMap {\n            {\"number\", 1337},\n            {\"string\", \"Hello World\"}\n        }}\n    },\n\n    // Meta methods may be registered aswell\n    {\n        {\"__tostring\", LUWRA_WRAP_MEMBER(Point, __tostring)}\n    }\n);",
            "title": "Register User Type with Constructor"
        },
        {
            "location": "/usertypes/#register-user-type-without-constructor",
            "text": "To register only the metatable associated with a user type, simply omit the constructor parameters\nand name from the call to  registerUserType .  luwra::registerUserType<Point>(\n    lua,\n\n    // Methods need to be declared here\n    {\n        {\"scale\", LUWRA_WRAP_MEMBER(Point, scale)},\n        {\"x\",     LUWRA_WRAP_MEMBER(Point, x)},\n        {\"y\",     LUWRA_WRAP_MEMBER(Point, y)},\n        {\"magic\", luwra::MemberMap {\n            {\"number\", 1337},\n            {\"string\", \"Hello World\"}\n        }}\n    },\n\n    // Meta methods may be registered aswell\n    {\n        {\"__tostring\", LUWRA_WRAP_MEMBER(Point, __tostring)}\n    }\n);  It is still possible to provide a constructor using the LUWRA_WRAP_CONSTRUCTOR  macro:  lua_CFunction ctor = LUWRA_WRAP_CONSTRUCTOR(Point, double, double);\nluwra::setGlobal(lua, \"Point\", ctor);",
            "title": "Register User Type without Constructor"
        },
        {
            "location": "/usertypes/#usage-in-lua",
            "text": "After you have registered your user type using one of the given methods, you can start using it in\nLua:  -- Instantiate 'Point'\nlocal point = Point(13, 37)\n\n-- Invoke 'scale' method\npoint:scale(1.5)\n\n-- Convert to string via '__tostring' meta method\nprint(point)\n\n-- Read properties 'x' and 'y'\nprint(point:x(), point:y())\n\n-- Set property 'x'\npoint:x(point.magic.number)",
            "title": "Usage in Lua"
        },
        {
            "location": "/usertypes/#manually-constructing-a-user-type",
            "text": "construct  provides this functionality. Given the user type and constructor\nparameters, it will construct the user type on top of the stack:  Point& my_point = luwra::construct<Point>(lua, 13.37, 73.31);\n\n// Changes on C++ side will be visible in Lua\nmy_point.scale(2);",
            "title": "Manually constructing a User Type"
        },
        {
            "location": "/usertypes/#registry-names",
            "text": "When registering the metatable for a user type, an automatically generated name will be used to\nstore it in the registry. When Luwra is used in a single executable or shared library, name\ncollisions should not happen. If your application consists of multiple seperate compiled units, it\nis highly recommended to prevent name collisions by defining the  LUWRA_REGISTRY_PREFIX  macro\nbefore including the Luwra headers. This macro changes the prefix for auto-generated registry names.  #define LUWRA_REGISTRY_PREFIX \"MyProject#\"\n#include <luwra.hpp>  Another way to prevent collisons is to give each user type its individual registry name. This can be\ndone using the  LUWRA_DEF_REGISTRY_NAME  macro.  struct MyUserType {\n    // ...\n};\n\nLUWRA_DEF_REGISTRY_NAME(MyUserType, \"MyUserType\")  This method will not prefix the registry name with the value of  LUWRA_REGISTRY_PREFIX .\nThe  LUWRA_DEF_REGISTRY_NAME  macro has to be used at the root namespace,\nusing it inside a namespace scope will have no effect.",
            "title": "Registry Names"
        }
    ]
}